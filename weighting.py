# -*- coding: utf-8 -*-
"""weighting.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12SzdnHuKKulwqBRUNHGKl4YI_l3mZE2a
"""

import sklearn.metrics as metrics

class ModelAggregator:
    def __init__(self, learners):
        self.learners = learners
        self.allocation = [1.0 for _ in learners]

    def make_prediction(self, input_data):
        model_outcomes = [learner.predict(input_data) for learner in self.learners]
        combined_outcomes = [allocation * outcome for allocation, outcome in zip(self.allocation, model_outcomes)]
        final_prediction = sum(combined_outcomes) / sum(self.allocation)
        return final_prediction

    def assess_performance(self, input_data_test, output_data_test):
        predictions_of_aggregate = self.make_prediction(input_data_test)
        error_of_aggregate = metrics.mean_squared_error(output_data_test, predictions_of_aggregate)
        return error_of_aggregate

    def optimize_allocations(self, input_data_test, output_data_test):
        aggregate_predictions = self.make_prediction(input_data_test)
        aggregate_error = metrics.mean_squared_error(output_data_test, aggregate_predictions)
        for idx, learner in enumerate(self.learners):
            individual_predictions = learner.predict(input_data_test)
            individual_error = metrics.mean_squared_error(output_data_test, individual_predictions)
            self.allocation[idx] *= individual_error / aggregate_error